package casm.Map;

import casm.ECS.Components.Collision.ColliderComponent;
import casm.ECS.Components.Collision.ColliderType;
import casm.ECS.Components.PositionComponent;
import casm.ECS.GameObject;
import casm.Factory.EntityFactory.EntityType;
import casm.Game;
import casm.Scenes.Scene;
import casm.Objects.Entities.Tile;
import casm.SpriteUtils.Assets;
import casm.SpriteUtils.AssetsCollection;
import casm.Utils.Vector2D;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

/**
 * Create the map from a json file given by parameter<br>
 * The JSON is generated by the <b>Tiled Map Editor</b>
 *
 * @see <a href="https://www.mapeditor.org/">Tiled Map Editor</a>
 */
public class Map {

    /**
     * <b>cols</b> - the number of columns of the map<br>
     * <b>rows</b> - the number of rows of the map<br>
     * <b>tileWidth</b> - the width of a tile<br>
     * <b>tileHeight</b> - the height of a tile<br>
     */
    private static int cols, rows, tileWidth, tileHeight;
    /**
     * <b>playerSpawnPosition</b> - the position where the player will be spawned<br>
     * <b>spawnDoor</b> - the position of the door where the player will be spawned<br>
     * <b>winDoor</b> - the position of the door where the player needs to walk throw to win<br>
     */
    private static Vector2D playerSpawnPosition, spawnDoor = null, winDoor = null;
    /**
     * The spawn positions of the enemies
     */
    private static HashMap<EntityType, Set<Vector2D>> enemiesSpawnPosition = new HashMap<>();
    /**
     * The spawn positions of the bonus hearts
     */
    private static HashSet<Vector2D> heartsSpawnPosition = new HashSet<>();

    /**
     * Load the map from the given JSON file, create the needed entities and add them to the scene
     *
     * @param scene        the scene where the entities will be added
     * @param path         the path to the JSON file
     * @param sprites_name the name of the sprite sheet(<i>Path: \resources\GameMaps\...</i>)
     */
    public static void loadMap(Scene scene, String path, String sprites_name) {
        enemiesSpawnPosition.clear();
        try {
            JSONObject json = (JSONObject) new JSONParser().parse(new FileReader(Paths.get("").toAbsolutePath() + "\\resources\\GameMaps\\" + path));
            JSONArray layers = (JSONArray) json.get("layers");

            tileWidth = Integer.parseInt(json.get("tilewidth").toString());
            tileHeight = Integer.parseInt(json.get("tileheight").toString());
            AssetsCollection.getInstance().addSpriteSheet(sprites_name, tileWidth, tileHeight);
            Assets sprites = AssetsCollection.getInstance().getSpriteSheet(sprites_name);

            int texture_id_offset = Integer.parseInt(((JSONObject) ((JSONArray) json.get("tilesets")).get(0)).get("firstgid").toString());

            layers.forEach(layer -> {
                JSONObject layerObj = (JSONObject) layer;
                if (layerObj.get("type").toString().equals("tilelayer")) {
                    rows = Integer.parseInt(layerObj.get("height").toString());
                    cols = Integer.parseInt(layerObj.get("width").toString());
                    int layer_id = Integer.parseInt(layerObj.get("id").toString());
                    JSONArray data = (JSONArray) layerObj.get("data");
                    String layerName = layerObj.get("name").toString();
                    if (Objects.equals(layerName, "collision")) {
                        for (int i = 0; i < rows; i++) {
                            for (int j = 0; j < cols; j++) {
                                int colliderType = Integer.parseInt(data.get(i * cols + j).toString());
                                if (colliderType != 0) {
                                    //Tile tile = (Tile) scene.getLayeringObjects().get(0).get(i * cols + j);
                                    for (GameObject testObj : scene.getLayeringObjects().get(0)) {
                                        if (testObj.getComponent(PositionComponent.class).position.equals(new Vector2D(j * tileWidth, i * tileHeight))) {
                                            Tile tile = (Tile) testObj;
                                            tile.addComponent(new ColliderComponent(ColliderType.values()[colliderType - 1], tile.getTileWidth(), tileHeight));
                                            if (colliderType - 1 == ColliderType.WIN_DOOR.ordinal())
                                                Objects.requireNonNull(Game.getLevelScene()).addToWinColliders(tile.getComponent(ColliderComponent.class).getCollider(ColliderType.WIN_DOOR));
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    } else
                        for (int i = 0; i < rows; i++) {
                            for (int j = 0; j < cols; j++) {
                                if (Long.parseLong(data.get(i * cols + j).toString()) > 0) {
                                    Tile tile = new Tile("tile", sprites, Long.parseLong(data.get(i * cols + j).toString()) - texture_id_offset, j, i);
                                    scene.addGameObjectToScene(tile);
                                    scene.addGameObjectToLayer(tile, layer_id);
                                }
                            }
                        }
                }
                if (layerObj.get("type").toString().equals("objectgroup")) {
                    JSONArray objectGroup = ((JSONArray) layerObj.get("objects"));
                    objectGroup.forEach(positionObject -> {
                        double x = Double.parseDouble(((JSONObject) positionObject).get("x").toString());
                        double y = Double.parseDouble(((JSONObject) positionObject).get("y").toString());
                        if (layerObj.get("name").toString().equals("player"))
                            playerSpawnPosition = new Vector2D(x, y);
                        if (layerObj.get("name").toString().equals("heart"))
                            heartsSpawnPosition.add(new Vector2D(x, y));
                        if (layerObj.get("name").toString().equals("spawn door")) {
                            double h = Double.parseDouble(((JSONObject) positionObject).get("height").toString());
                            spawnDoor = new Vector2D(x, y - h);
                        }
                        if (layerObj.get("name").toString().equals("win door")) {
                            double h = Double.parseDouble(((JSONObject) positionObject).get("height").toString());
                            winDoor = new Vector2D(x, y - h);
                        }
                        if (layerObj.get("name").toString().equals("enemies")) {
                            EntityType type = null;
                            switch (((JSONObject) positionObject).get("name").toString().toLowerCase()) {
                                case "weasel" -> type = EntityType.WEASEL_FISHERMAN;
                                case "catfish" -> type = EntityType.CATFISH;
                                case "turtle" -> type = EntityType.TURTLE_KING;
                            }
                            if (type != null) {
                                if (!enemiesSpawnPosition.containsKey(type))
                                    enemiesSpawnPosition.put(type, new HashSet<>());
                                enemiesSpawnPosition.get(type).add(new Vector2D(x, y));
                            }
                        }
                    });

                }

            });
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return;
        } catch (IOException | ParseException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @return the number of columns of the map
     */
    public static int getCols() {
        return cols;
    }

    /**
     * @return the number of rows of the map
     */
    public static int getRows() {
        return rows;
    }

    /**
     * @return the width of a tile
     */
    public static int getTileWidth() {
        return tileWidth;
    }

    /**
     * @return the height of a tile
     */
    public static int getTileHeight() {
        return tileHeight;
    }

    /**
     * @return the spawn position of the player
     */
    public static Vector2D getPlayerSpawnPosition() {
        return playerSpawnPosition;
    }

    /**
     * @return the spawn position of the spawn door
     */
    public static Vector2D getSpawnDoor() {
        return spawnDoor;
    }

    /**
     * @return the spawn position of the win door
     */
    public static Vector2D getWinDoor() {
        return winDoor;
    }

    /**
     * @return the spawn position of the enemies
     */
    public static HashMap<EntityType, Set<Vector2D>> getEnemiesSpawnPosition() {
        return enemiesSpawnPosition;
    }

    /**
     * @param type the type of the enemies
     * @return the spawn position of the enemies of the given type
     */
    public static Set<Vector2D> getEnemiesSpawnPositionByType(EntityType type) {
        return enemiesSpawnPosition.get(type);
    }

    /**
     * @return the spawn position of the bonus hearts
     */
    public static HashSet<Vector2D> getHeartsSpawnPosition() {
        return heartsSpawnPosition;
    }
}
